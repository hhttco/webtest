<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>æ˜Ÿé™…è”åŠ¨ï¼š20ç§æ°´æœå¤§çˆ†å‘</title>
    <style>
        :root { --neon: #00f2ff; --bg: #050810; }
        body { margin: 0; background: var(--bg); color: #fff; font-family: sans-serif; overflow: hidden; touch-action: none; }
        
        /* èƒ½é‡æ¡ï¼šç”Ÿå­˜æ ¸å¿ƒ */
        #energyContainer { position: absolute; top: 40vh; left: 0; width: 100%; height: 8px; background: #222; z-index: 10; border-top: 1px solid var(--neon); }
        #energyBar { height: 100%; width: 100%; background: linear-gradient(90deg, #ff0055, #00f2ff); transition: width 0.1s linear; }
        
        #gameLayout { display: flex; flex-direction: column; height: 100vh; }
        #topArea { display: flex; height: 40vh; }
        .canvas-box { flex: 1; position: relative; border: 1px solid #111; }
        canvas { width: 100%; height: 100%; display: block; }
        
        /* æ¶ˆæ¶ˆä¹åŒºï¼š5åˆ—å¸ƒå±€ä»¥å®¹çº³æ›´å¤šæ°´æœ */
        #matchGrid { flex: 1; background: #0a0e1a; display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; padding: 10px; overflow-y: auto; }
        .block { 
            background: #16213e; border: 1px solid #0f3460; display: flex; 
            justify-content: center; align-items: center; font-size: 26px; 
            aspect-ratio: 1; border-radius: 8px; transition: transform 0.1s; 
        }
        .block:active { transform: scale(0.9); }
        .block.active { border-color: var(--neon); background: #1a3a5f; box-shadow: 0 0 10px var(--neon); }
        .block.none { visibility: hidden; opacity: 0; pointer-events: none; }

        #overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center; }
        button { padding: 18px 50px; font-size: 22px; background: var(--neon); border: none; border-radius: 50px; cursor: pointer; font-weight: bold; box-shadow: 0 0 20px var(--neon); }
        .score-display { position: absolute; top: 10px; right: 10px; color: var(--neon); font-family: monospace; font-size: 18px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="overlay">
        <h1 style="color:var(--neon); letter-spacing:4px;">FRUIT CORE</h1>
        <button id="startBtn">å¯åŠ¨æ°´æœå¼•æ“</button>
        <p style="color:#aaa; margin-top:20px; font-size:13px;">
            ğŸ è›‡åƒè±† -> ç”Ÿäº§æ°´æœå¯¹<br>
            ğŸ‡ æ¶ˆæ°´æœ -> å›å¤èƒ½é‡+æ‰‡å½¢å¼¹<br>
            âš ï¸ èƒ½é‡è€—å°½æˆ–æ’æœº -> æ¸¸æˆç»“æŸ
        </p>
    </div>

    <div id="energyContainer"><div id="energyBar"></div></div>

    <div id="gameLayout">
        <div id="topArea">
            <div class="canvas-box"><canvas id="sCanvas"></canvas></div>
            <div class="canvas-box">
                <div class="score-display">SCORE: <span id="scoreVal">0</span></div>
                <canvas id="pCanvas"></canvas>
            </div>
        </div>
        <div id="matchGrid"></div>
    </div>

    <script>
        const sCanvas = document.getElementById('sCanvas'), pCanvas = document.getElementById('pCanvas');
        const sCtx = sCanvas.getContext('2d'), pCtx = pCanvas.getContext('2d');
        const grid = document.getElementById('matchGrid'), startBtn = document.getElementById('startBtn');
        const energyBar = document.getElementById('energyBar'), scoreEl = document.getElementById('scoreVal');

        function resize() {
            sCanvas.width = pCanvas.width = window.innerWidth / 2;
            sCanvas.height = pCanvas.height = window.innerHeight * 0.4;
        }
        window.onresize = resize; resize();

        let active = false, score = 0, energy = 100;
        let snake = [{x:10, y:10}], food = {x:5, y:5}, sDir = {x:1, y:0};
        let planeX = 20, bullets = [], enemies = [], selected = null;

        // ğŸ‡ 20ç§ä¸åŒç±»å‹çš„æ°´æœåˆ—è¡¨ [Unicode Emoji](https://unicode.org)
        const fruits = [
            'ğŸ','ğŸŒ','ğŸ‡','ğŸ‰','ğŸ“','ğŸ’','ğŸ','ğŸ¥­','ğŸ¥','ğŸ',
            'ğŸ‘','ğŸŠ','ğŸ‹','ğŸˆ','ğŸ','ğŸ«','ğŸ¥¥','ğŸ…','ğŸ¥‘','ğŸŒ½'
        ];

        // æ ¸å¿ƒï¼šå¢åŠ æ°´æœå¯¹
        function addFruitPair() {
            const fruit = fruits[Math.floor(Math.random() * fruits.length)];
            for (let i = 0; i < 2; i++) {
                const el = document.createElement('div');
                el.className = 'block'; el.innerText = fruit;
                const item = { fruit, el };
                el.onclick = () => {
                    if (!active) return;
                    if (!selected) {
                        selected = item; el.classList.add('active');
                    } else {
                        if (selected !== item && selected.fruit === item.fruit) {
                            selected.el.classList.add('none'); el.classList.add('none');
                            energy = Math.min(100, energy + 12); // å›èƒ½
                            score += 50; scoreEl.innerText = score;
                        }
                        if (selected.el) selected.el.classList.remove('active');
                        selected = null;
                    }
                };
                grid.appendChild(el);
            }
            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨ä»¥ä¾¿çœ‹åˆ°æ–°æ°´æœ
            grid.scrollTop = grid.scrollHeight;
        }

        // è§¦æ§é€»è¾‘
        sCanvas.addEventListener('touchstart', e => {
            const rect = sCanvas.getBoundingClientRect();
            const tx = e.touches[0].clientX - rect.left;
            const ox = sDir.x, oy = sDir.y;
            if (tx > sCanvas.width/2) { sDir.x = -oy; sDir.y = ox; } else { sDir.x = oy; sDir.y = -ox; }
        });
        pCanvas.addEventListener('touchmove', e => {
            e.preventDefault();
            planeX = e.touches[0].clientX - pCanvas.getBoundingClientRect().left - 20;
        }, {passive: false});

        function loop() {
            if (!active) return;

            // 1. èƒ½é‡è¡°å‡ (éšæ—¶é—´å˜å¿«)
            energy -= (0.12 + score/10000); 
            energyBar.style.width = energy + "%";
            if (energy <= 0) return gameOver("æ ¸å¿ƒæœæ±è€—å°½ï¼");

            // 2. è›‡åŒºæ¸²æŸ“
            sCtx.fillStyle = '#050810'; sCtx.fillRect(0,0,sCanvas.width, sCanvas.height);
            sCtx.fillStyle = '#2ecc71'; snake.forEach(p => sCtx.fillRect(p.x*sCanvas.width/20, p.y*sCanvas.height/20, sCanvas.width/20-1, sCanvas.height/20-1));
            sCtx.fillStyle = '#ff0055'; sCtx.beginPath(); sCtx.arc((food.x+0.5)*sCanvas.width/20, (food.y+0.5)*sCanvas.height/20, sCanvas.width/40, 0, Math.PI*2); sCtx.fill();

            // 3. æˆ˜æœºåŒºæ¸²æŸ“
            pCtx.fillStyle = 'rgba(0,5,15,0.3)'; pCtx.fillRect(0,0,pCanvas.width, pCanvas.height);
            pCtx.fillStyle = '#00f2ff'; pCtx.fillRect(planeX, pCanvas.height-40, 40, 12);
            
            // åªè¦æœ‰èƒ½é‡å°±è‡ªåŠ¨æ‰‡å½¢å°„å‡»
            if (energy > 5) {
                bullets.push({x: planeX+18, y: pCanvas.height-40, vx: -1.5}, {x: planeX+18, y: pCanvas.height-40, vx: 0}, {x: planeX+18, y: pCanvas.height-40, vx: 1.5});
            }

            bullets.forEach((b, i) => {
                b.y -= 10; b.x += b.vx;
                pCtx.fillStyle = '#fffb00'; pCtx.fillRect(b.x, b.y, 3, 12);
                if (b.y < 0) bullets.splice(i, 1);
            });

            // æ•Œäººä¸ç¢°æ’
            if (Math.random() < 0.05 + score/20000) enemies.push({x: Math.random()*pCanvas.width, y: -20, r: 10 + Math.random()*10});
            enemies.forEach((e, i) => {
                e.y += 3; pCtx.fillStyle = '#ff4400'; pCtx.beginPath(); pCtx.arc(e.x, e.y, e.r, 0, Math.PI*2); pCtx.fill();
                
                // å­å¼¹å‡»ä¸­
                bullets.forEach((b, bi) => {
                    if (Math.abs(b.x - e.x) < e.r && Math.abs(b.y - e.y) < e.r) {
                        enemies.splice(i, 1); bullets.splice(bi, 1);
                        score += 10; scoreEl.innerText = score;
                    }
                });
                // æ’å‡»é£æœº
                if (Math.abs(planeX + 20 - e.x) < 25 && Math.abs(pCanvas.height - 30 - e.y) < 25) {
                    enemies.splice(i, 1); energy -= 20; // æ’å‡»é‡ç½šèƒ½é‡
                    if(energy < 0) energy = 0;
                }
                if (e.y > pCanvas.height) enemies.splice(i, 1);
            });

            requestAnimationFrame(loop);
        }

        function gameOver(msg) {
            active = false; alert(msg + "\næœ€ç»ˆç§¯åˆ†: " + score); location.reload();
        }

        startBtn.onclick = () => {
            document.getElementById('overlay').style.display = 'none';
            active = true; resize();
            for(let i=0; i<5; i++) addFruitPair(); // åˆå§‹æä¾›10ä¸ªæ°´æœ
            
            // è›‡çš„è®¡æ—¶å™¨
            setInterval(() => {
                if (!active) return;
                const head = {x: snake[0].x + sDir.x, y: snake[0].y + sDir.y};
                // è›‡æ’å¢™å¤„ç†ï¼šè‡ªåŠ¨åå¼¹
                if(head.x<0 || head.x>=20 || head.y<0 || head.y>=20) { sDir={x:-sDir.x, y:-sDir.y}; return; }
                snake.unshift(head);
                if(head.x === food.x && head.y === food.y) {
                    food = {x: Math.floor(Math.random()*20), y: Math.floor(Math.random()*20)};
                    addFruitPair(); // è”åŠ¨ï¼šè›‡åƒè±†äº§ç”Ÿæ°´æœå¯¹
                } else { snake.pop(); }
            }, 180);

            loop();
        };
    </script>
</body>
</html>
